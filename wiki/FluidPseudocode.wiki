=Particle-Based Viscoelastic Fluid Simulation Psuedocode=

=New Structure Implementation=
_Suggested implementation changes, 14 Sept, 2008_
 * Blob Particles have a Hashtable of Neighbours ( key being theNeighbourParticle )
 * Each Neighbour is made up of a Particle and an optional Spring
 * New Function added into Blob Particles : 'updateneighbours'
  * Contacts Spatial Grid and Requests Neighbours
   # If Already in List, Update the Current Element ( if required )
   # If Not in List, Add to List
   # If In Current List, but Not in New List, Remove from List 
    * Possibly make this last step a method in it's own, as removal might be a bit intensive, may make sense to only do this at the end of each cycle, rather than doing constant add/removes.  It doesn't matter so much if we have too many neighbours, but it will matter if we miss some.

==Tests==
 * Access via Particle/Neighbour Pair
  * Particle.neighbours[theNeighbour].spring
 * Access via Spring Iteration
  * Possible use of the current springs list, easy to iterate through then.
  * Other alternatives would be to use a spring hashtable with springID.  and store the springID instead of the actual spring inside neighbours.

=Details=
Still some things unknown : 
 * r^ij
  * We know it's a unit Vector.  But how to calculate it, and what it signifies is still not 100% Sure.  
  * We read that a unit vector is equal to the vector / the normalised vector.  I think I might have a normalising function coded into my Vector2D Class.  Will attempt with that value tomorrow.
  * Normalising Function is as follows : 
{{{
     public function normalize():void
     {
       var length:Number = length();
       if (length == 0)
       {
         return;
       }
       x /= length;
       y /= length;
     }
    }}}
  * Ok, I don't think that's right.  I asked my friend :

`"You calculate the 2-norm (pythagoras' theorem) and divide the whole vector by it`

`so if you had the vector (3,4), you'd have the length being sqrt(3^2 + 4^2) = 5`

`so scaling it would give you (0.6, 0.8)"`

the scalar vector product
say you have two vectors a and b
a . b means that you add up a(1)*b(1) + a(2)*b(2) ...
for however long a and b are

==Algorithm 1 : Simulation Step==
{{{
for each Particle{
  // Apply Gravity
  Particle.velocity += gravity;
}

applyViscosity();

for each Particle{
  // Save Previous Pos
  Particle.prevPos = Particle.pos;
  // Move to Predicted Pos
  Particle.pos += Particle.velocity;
}

adjustSprings();
applySpringDisplacements();
doubleDensityRelaxation();
resolveCollisions();

for each Particle{
  computeNextVel();
}
}}}

==Algorithm 2 : Double Density Relaxation==
{{{
for each Particle[i]{
  density = 0;
  nearDensity = 0;
  for each Particle[j] who is neighbours with Particle[i]{
    // Compute Density and Near Density
    q = particleDistance/threshold;
    if(q < 1){
      density += (1 - q)^2;
      nearDensity += (1 - q)^3;
    }
  }

  // Compute Pressure and Near-Pressure
  pressure = stiffness * (density - restDensity);
  nearPressure = nearStiffness * nearDensity;
  dx = (0,0);

  for each Particle[j] who is neighbours with Particle[i]){
    q = particleDistance/threshold;
	if(q < 1){
	  // Apply Displacements
      displacement = (pressure(1-q) + newPressure(1-q)^2) * r^ij;
	  Particle[j].pos += D / 2;
	  dx += -1 * (D / 2);
	}
  }
  Particle[i].pos += dx;
}
}}}

==Algorithm 3 : Spring Displacement==
{{{
for each spring{
  displacement = springStiffness * (1 * springRestLength / threshold) * (springRestLength - distance) * r^ij
  thePoint[i].pos += -1 * (D / 2);
  thePoint[j].pos += D / 2;
}
}}}

==Algorithm 4 : Spring Adjustment==
{{{
for each neighbor pair{
  q = distance/threshold;
  if(q < 1){
    if(notConnected){
      createSpring(restLength = threshold);
    }
    deformation = yieldRatio * restLength;
    if(distance > restLengthConstant + deformation){
      // Stretch
      restLength = restLength + plasticityConstant(distance - restLengthConstant - deformation);
    } else if (distance < restLengthConstant - deformation) {
      // Compress
      restLength = restLength - plasticityConstant(restLengthConstant - deformation - distance);
    }
  }
  for each Spring{
    if(restLength > threshold){
      removeSpring();
    }
  }
}
}}}

==Algorithm 5 : Viscosity Impulses==
{{{
for each neighbor pair{
  q = distance / threshold;
  if(q < 1){
    u = (Particle[i].velocity - Particles[j].velocity) . r^ij;
    if(u > 0){
      impulseDependence = (1 - q) * (variable1 * u + variable2 * u^2) * r^ij;
      Particle[i].velocity += -1 * (impulseDependence / 2);
      Particle[j].veloicty += impulseDependence / 2;
    }
  }
}
}}}

==Algorithm 6 : Particle-Body Interactions==
{{{
for each body{
  body.origPos = body.pos;
  body.pos += body.velocity;
  // Not sure about angular velocity.  is it as simple as adding it ? or is it rotational ? 
  body.pos += body.angularVelocity;
  
  forceBuffer = 0;
  torqueBuffer = 0;  
}}}